# -*- coding: utf-8 -*-
"""KW_MMDS - MidTerm HW1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A2vdbVSrk2Tmn78-WO6CsE9Tg5pLAGJB

# KW_MMDS - MidTerm HW 1
## People You Might Know

### Setup

Let's setup Spark on your Colab environment.  Run the cell below!
"""

!pip install pyspark
!pip install -U -q PyDrive
!apt install openjdk-8-jdk-headless -qq
import os
os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"

"""Now we authenticate a Google Drive client to download the file we will be processing in our Spark job.

**Make sure to follow the interactive instructions.**
"""

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

# Authenticate and create the PyDrive client
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

id='198T51ho_jgrOiS3VuPdR8g0yGJGQNV9u'
downloaded = drive.CreateFile({'id': id})
downloaded.GetContentFile('soc-LiveJournal1Adj.txt')

"""If you executed the cells above, you should be able to see the file *soc-LiveJournal1Adj.txt* under the "Files" tab on the left panel."""

# Let's import the libraries we will need
from pyspark.sql import *
from pyspark.sql.functions import *
from pyspark import SparkContext
from operator import itemgetter
import pandas as pd
import itertools

# create the Spark Session
spark = SparkSession.builder.getOrCreate()

# create the Spark Context
sc = spark.sparkContext

"""###Data
* Associated data file is soc-LiveJournal1Adj.txt.
* The file contains the adjacency list and has multiple lines in the following format:
<br>```<User><TAB><Friends>```<br>
Here, ```<User>``` is a unique integer ID corresponding to a unique user and ```<Friends>``` is
a comma separated list of unique IDs corresponding to the friends of the user with the
unique ID ```<User>```. Note that the friendships are mutual (i.e., edges are undirected):
if $A$ is friend with $B$ then $B$ is also friend with $A$. The data provided is consistent
with that rule as there is an explicit entry for each side of each edge.
Algorithm: Let us use a simple algorithm such that, for each user $U$, the algorithm recommends $N = 10$ users who are not already friends with $U$, but have the most number of
mutual friends in common with $U$.

###Algorithm 
Let us use a simple algorithm such that, for each user U, the algorithm recommends N = 10 users who are not already friends with U, but have the most number of
mutual friends in common with U.

### Your task

#### Text (Handwriting)

Submit your spark pipeline.

Problem.Write a Spark program that implements a simple "People You Might Know" social network friendship recommendation algorithm. The key idea is that if two people have a lot of mutual friends, then the system should recommend that they connect with each other. Please print the recommendations for the users with following user IDs: 7785, 19365, 27552, 38737, 44070. The recommendations should be ordered in decreasing number of mutual friends. If there are recommended users with the same number of mutual friends, then output those user IDs in numerically ascending order.

For sanity check, your top 10 recommendations for user ID 11 should be:
<br>
27552, 7785, 27573, 27574, 27589, 27590, 27600, 27617, 27620, 27667.
"""

# YOUR CODE HERE

# 파일 읽기
RDDs = sc.textFile('soc-LiveJournal1Adj.txt')

# RDD 형식 (string): '유저번호\t친구목록'
RDDs.take(5)

# RDD 변환 (list of two strings): ['유저번호', '친구목록']
RDDs = RDDs.map(lambda line: line.split())
RDDs.take(5)

# RDD 변환 (tuple): ('유저번호', ['친구1', '친구2', ...]), 필터는 친구목록 없는 유저 걸러내는 용도
RDDs = RDDs.filter(lambda lst:len(lst)==2).map(lambda lst: (lst[0], lst[1].split(",")))
RDDs.take(1)

# RDD 변환 (tuple): (유저번호, [친구1, 친구2, ...])
RDDs = RDDs.map(lambda tuple: (int(tuple[0]), list(map(int, tuple[1]))))
RDDs.take(1)

# 모든 친구 쌍 (친구a, 친구b)에 대해 ((친구a, 친구b), 1) 생성
friendsCandidate = RDDs.flatMap(lambda tuple: [(pair, 1) for pair in itertools.permutations(tuple[1], 2)])
friendsCandidate.take(10)

# 친구 리스트에 있는 친구ID에 대해 ((유저ID, 친구ID), 값) 생성
alreadyFriends = alreadyFriends = RDDs.flatMap(lambda tuple: [((tuple[0], friend),-100) for friend in tuple[1]])
alreadyFriends.take(5)

# Union
tuples = friendsCandidate.union(alreadyFriends)

# Reduce
tuples = tuples.reduceByKey(lambda a,b:a+b).filter(lambda tuple:tuple[1]>=0)
tuples.take(10)

# ((유저ID,친구ID), 숫자)를 (유저ID, (친구ID, 숫자))로 변환
tuples = tuples.map(lambda tuple: (tuple[0][0], (tuple[0][1],tuple[1])))
tuples.take(10)

# 유저별로 (친구ID, 숫자)를 리스트로 묶기
grouped = tuples.groupByKey().mapValues(list)
grouped.take(1)

# 친구ID로 오름차순 정렬
grouped = grouped.map(lambda tuple: (tuple[0], sorted(tuple[1])))
grouped.take(1)

# 숫자로 내림차순 정렬
grouped = grouped.map(lambda tuple: (tuple[0], sorted(tuple[1], key=itemgetter(1), reverse=True)))
grouped.take(1)

# 11번 유저의 추천 친구
user_id = 11
res = grouped.filter(lambda tuple:tuple[0]==user_id)
res.take(1)

# 많이 등장한 10개만 가져오기
res = res.flatMap(lambda tuple: [tuple[1][i][0] for i in range(10)])
res.take(10)
